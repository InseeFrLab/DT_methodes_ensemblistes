<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>ajouts_boosting – Introduction aux méthodes ensemblistes</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../chapters/chapter3/0-intro.html" rel="next">
<link href="../../chapters/chapter2/4-boosting.html" rel="prev">
<link href="../../images/favicon.ico" rel="icon">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-1959eab64d7f8dc8170c6f7139d73ad1.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/quarto-contrib/fontawesome6-1.2.0/all.min.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/fontawesome6-1.2.0/latex-fontsize.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../chapters/chapter2/0-intro.html">Présentation formelle des algorithmes</a></li><li class="breadcrumb-item"><a href="../../chapters/chapter2/ajouts_boosting.html">Sujets avancés</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-center sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">Introduction aux méthodes ensemblistes</a> 
        <div class="sidebar-tools-main">
    <a href="../.././pdf/dt_methodes_ensemblistes.pdf" title="NMFS Open Science" class="quarto-navigation-tool px-1" aria-label="NMFS Open Science"><i class="bi bi-file-pdf-fill"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction aux méthodes ensemblistes</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../chapters/chapter1/0-intro.qmd" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Survol des méthodes ensemblistes</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter1/1-survol.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Aperçu des méthodes ensemblistes</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter1/2-comparaison_GB_RF.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Comparaison entre forêts aléatoires et <em>gradient boosting</em></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../chapters/chapter2/0-intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Présentation formelle des algorithmes</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter2/1-CART.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">La brique élémentaire: l’arbre de décision</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter2/2-bagging.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Le <em>bagging</em></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter2/3-random_forest.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">La forêt aléatoire</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter2/4-boosting.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Le <em>boosting</em></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter2/ajouts_boosting.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Sujets avancés</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../chapters/chapter3/0-intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Comment bien utiliser les algorithmes?</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter3/1-preparation_donnees.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Préparation des données</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter3/2-guide_usage_RF.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Guide d’usage des forêts aléatoires</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter3/3-guide_usage_GB.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Guide d’usage du <em>gradient boosting</em></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#sec-sujets-avances" id="toc-sec-sujets-avances" class="nav-link active" data-scroll-target="#sec-sujets-avances"><span class="header-section-number">1</span> Sujets avancés</a>
  <ul class="collapse">
  <li><a href="#sec-missing-values" id="toc-sec-missing-values" class="nav-link" data-scroll-target="#sec-missing-values"><span class="header-section-number">1.1</span> Le traitement des variables manquantes</a></li>
  <li><a href="#sec-continuous-variables-hist" id="toc-sec-continuous-variables-hist" class="nav-link" data-scroll-target="#sec-continuous-variables-hist"><span class="header-section-number">1.2</span> Le traitement des variables continues: l’utilisation des histogrammes</a></li>
  <li><a href="#sec-categorical-variables-encoding" id="toc-sec-categorical-variables-encoding" class="nav-link" data-scroll-target="#sec-categorical-variables-encoding"><span class="header-section-number">1.3</span> Le traitement des variables catégorielles</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/inseefrlab/DT_methodes_ensemblistes/edit/main/chapters/chapter2/ajouts_boosting.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/inseefrlab/DT_methodes_ensemblistes/blob/main/chapters/chapter2/ajouts_boosting.qmd" class="toc-action"><i class="bi empty"></i>View source</a></li><li><a href="https://github.com/inseefrlab/DT_methodes_ensemblistes/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../chapters/chapter2/0-intro.html">Présentation formelle des algorithmes</a></li><li class="breadcrumb-item"><a href="../../chapters/chapter2/ajouts_boosting.html">Sujets avancés</a></li></ol></nav></header>




<section id="sec-sujets-avances" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="sec-sujets-avances"><span class="header-section-number">1</span> Sujets avancés</h2>
<section id="sec-missing-values" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="sec-missing-values"><span class="header-section-number">1.1</span> Le traitement des variables manquantes</h3>
<p>A COMPLETER</p>
</section>
<section id="sec-continuous-variables-hist" class="level3" data-number="1.2">
<h3 data-number="1.2" class="anchored" data-anchor-id="sec-continuous-variables-hist"><span class="header-section-number">1.2</span> Le traitement des variables continues: l’utilisation des histogrammes</h3>
<p><strong>L’algorithme de détermination des critères de partition (<em>split-finding algorithm</em>) est un enjeu de performance essentiel dans les méthodes ensemblistes.</strong> En effet, l’algorithme le plus simple qui consiste à énumérer tous les critères de partition possibles (en balayant toutes les valeurs de toutes les variables) s’avère très coûteux à utiliser dès lors que les données contiennent soit un grand nombre de variables, soit des variables continues prenant un grand nombre de valeurs. C’est pourquoi cet algorithme a fait l’objet de multiples améliorations et optimisations visant à réduire leur coût computationnel sans dégrader la qualité des critères de partition.</p>
<p>L’utilisation d’histogrammes (<em>histogram-based algorithms</em>) est une approche efficace qui permet de réduire de manière significative le coût computationnel lié à la recherche des <em>splits</em> optimaux en discrétisant les variables continues. Elle est proposée par toutes les implémentations courantes du <em>gradient boosting</em> (XGBoost, LightGBM, CatBoost et scikit-learn). Elle comprend deux caractéristiques principales:</p>
<ul>
<li><strong>Discrétisation</strong>: avant le début de l’entraînement, chaque variable continue est discrétisée en un nombre limité d’intervalles (<em>bins</em>), construits le plus souvent à partir de ses quantiles. Ce processus est appelé <em>binning</em>. Par exemple, une variable continue uniformément distribuée de 0 à 100 peut être divisée en dix intervalles (<span class="math inline">\([0, 10), [10, 20), \dots, [90, 100)\)</span>). Le nombre maximal de <em>bins</em> est un hyperparamètre qui peut parfois jouer un rôle important. <!-- - __Construction de l'histogramme__: après la discrétisation, un histogramme est construit pour chaque variable continue; il résume combien d'observations appartiennent à chaque _bin_, ainsi que la somme des gradients et la somme des hessiennes de ces observations (il s'agit des quantités $\sum_{i \in \text{bin}} g_i$ et $\sum_{i \in \text{bin}} h_i$ mentionnées dans l'équation @eq-w-j-optimal. --></li>
<li><strong>Énumération restreinte</strong>: l’algorithme de détermination des critères de partition ne considère que les bornes des intervalles précédemment définies (10, 20, 30, etc. dans l’exemple précédent) et non l’ensemble des valeurs prises par les variables continues. Cette modification se traduit par une nette accélération de l’entraînement, dans la mesure où le nombre de <em>bins</em> est en général beaucoup plus faible que le nombre de valeurs uniques des variables continues. <!-- - __Mise à jour de l'histogramme__: G et H sont mis à jour après chaque arbre. --></li>
</ul>
</section>
<section id="sec-categorical-variables-encoding" class="level3" data-number="1.3">
<h3 data-number="1.3" class="anchored" data-anchor-id="sec-categorical-variables-encoding"><span class="header-section-number">1.3</span> Le traitement des variables catégorielles</h3>
<!-- IL NE FAUT PAS SUPPRIMER CE COMMENTAIRE. -->
<!-- Faire en sorte que la police Font Awesome soit chargée -->
<!--  -->
<!-- IL NE FAUT PAS SUPPRIMER CE COMMENTAIRE. -->
<section id="une-diversité-dapproches" class="level4" data-number="1.3.1">
<h4 data-number="1.3.1" class="anchored" data-anchor-id="une-diversité-dapproches"><span class="header-section-number">1.3.1</span> Une diversité d’approches</h4>
<p>A l’origine, les arbres CART ont été conçus pour partitionner l’espace en utilisant exclusivement des variables numériques, et ne pouvaient pas mobiliser les variables catégorielles sans un retraitement préalable. Plusieurs <strong>méthodes d’encodage</strong> (<em>one-hot-encoding</em>, <em>ordinal encoding</em>, <em>target encoding</em>) ont donc été développées pour surmonter ce problème en transformant les variables catégorielles en variables numériques; elles ne sont d’ailleurs pas spécifiques aux méthodes ensemblistes à base d’arbres. Depuis le milieu des années 2010, une nouvelle approche efficace et spécifique aux méthodes ensemblistes a été introduite dans les implémentations du <em>gradient boosting</em> (<em>native support for categorical features</em>). Ce paragraphe présente ces différentes approches des variables catégorielles, et précise quelle approche est proposée par les différentes implémentations.</p>
<p>Les trois approches d’encodage les plus courantes sont les suivantes:</p>
<ul>
<li><p>Le <strong><em>one-hot encoding</em></strong> consiste à transformer une variable catégorielle en une série de variables binaires qui représentent chacune une modalité de la variable; pour chaque observation, seule la colonne correspondant à la modalité de la variable catégorielle aura la valeur 1, et toutes les autres auront la valeur 0. Cette approche permet de représenter des catégories de manière numérique de façon très simple et sans leur attribuer un ordre. Toutefois, le <em>one-hot encoding</em> augmente fortement la dimensionnalité des données (ce qui ralentit l’entraînement et augmente les besoins en mémoire), et est inutilisable lorsque les variables catégorielles présentent un nombre de modalités<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p></li>
<li><p>L’<strong><em>ordinal encoding</em></strong> consiste à attribuer un entier unique à chaque modalité d’une variable catégorielle. Par exemple, la catégorie “Sans diplôme” sera encodée par la valeur 0, la catégorie “Baccalauréat ou moins” sera encodée par 1, etc. Simple à mettre en œuvre, cette approche permet de remplacer la variable catégorielle par une unique variable numérique et est donc utile pour traiter les variables présentant un grand nombre de modalités, pour lesquelles le <em>one-hot encoding</em> est impraticable. Elle est particulièrement adaptée aux variables catégorielles qui sont naturellement ordonnées (exemples: niveau de diplôme, catégorie d’âge, étage d’un appartement…). En revanche, cette approche est peu adaptée aux variables non ordonnées (exemples: secteur d’activité, département, pays…) car elle introduit un ordre fictif qui peut perturber les modèles qui interprètent les entiers comme des valeurs ordonnées.</p></li>
<li><p>Le <strong><em>target encoding</em></strong> consiste à remplacer chaque modalité d’une variable catégorielle par la moyenne de la variable cible pour cette modalité. Cette approche est notamment proposée par CatBoost<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> et par scikit-learn<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. Comme l’<em>ordinal encoding</em>, cette approche permet d’obtenir une unique variable numérique et est donc utile pour traiter les variables présentant un grand nombre de modalités. Par ailleurs, le <em>target encoding</em> fonctionne bien avec la méthode des histogrammes décrite précédemment, dans la mesure où les valeurs encodées sont par construction ordonnées en fonction de leur association avec la variable cible. Toutefois, il est important d’utiliser le <em>target encoding</em> en lissant la moyenne ou en recourant à une validation croisée car il est sujet au surapprentissage. De plus, les implémentations existantes réalisent l’encodage une seule fois avant l’entraînement au niveau de l’ensemble des données d’entraînement, pas au niveau de chaque <em>split</em>; l’ordre des modalités qui résulte de l’encodage peut être peu pertinent sur certaines parties des données d’entraînement si celles-ci présentent un haut degré d’hétérogénéité.</p></li>
</ul>
<p>La dernière approche, appelée <strong>support natif des variables catégorielles</strong> (<strong><em>native support for categorical features</em></strong>) n’est pas un encodage et est une spécificité des implémentations du <em>gradient boosting</em>. Cette approche a été introduite par <a href="https://lightgbm.readthedocs.io/en/latest/Features.html#optimal-split-for-categorical-features">LightGBM</a>, puis reprise par <a href="https://xgboost.readthedocs.io/en/latest/tutorials/categorical.html">XGBoost</a> et <a href="https://scikit-learn.org/stable/modules/ensemble.html#categorical-features-support">scikit-learn</a>. Dans cette approche, l’objectif est de déterminer le meilleur <em>split</em> directement à partir des modalités d’une variable catégorielle, en les séparant en deux sous-ensembles (par exemple : {‘A’, ‘B’, ‘C’} et {‘D’, ‘E’, ‘F’} pour une variable comportant six modalités). La difficulté est qu’il est souvent impossible en pratique de trouver le partitionnement optimal par une énumération exhaustive des partitions possibles, car il existe <span class="math inline">\(2^{k-1} - 1\)</span> partitions possibles pour une variable à <span class="math inline">\(k\)</span> modalités. C’est pourquoi le support natif des variables catégorielles repose sur une autre méthode plus efficace dont l’optimalité a été démontrée par <span class="citation" data-cites="fisher1958grouping">Fisher (<a href="#ref-fisher1958grouping" role="doc-biblioref">1958</a>)</span>: à chaque split, les modalités sont triées selon <span class="math inline">\(-\frac{\sum_{i} g_i}{\sum_{i} h_i}\)</span> <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>, puis le meilleur <em>split</em> est choisi en testant les différentes divisions possibles de cette liste triée. Par exemple, si pour un <em>split</em> donné les modalités sont triées dans l’ordre ABDFEC, l’algorithme examinera les <span class="math inline">\(k-1\)</span> <em>splits</em> A|BDFEC, AB|DFEC, ABD|FEC, etc. Cette approche peut être considérée comme une variante optimisée du <em>target encoding</em>, avec deux différences notables: l’encodage des modalités se fait à partir du gradient et de la hessienne de la fonction de perte (et non à partir de <span class="math inline">\(y\)</span>), et cet encodage a lieu à chaque <em>split</em> et non une seule fois avant l’entraînement. Par ailleurs, cette approche peut rencontrer des difficultés quand les variables catégorielles comprennent un nombre très élevé des modalités (au-delà de quelques centaines).</p>
<!-- 
https://stats.stackexchange.com/questions/501391/interpretation-of-gradient-and-hessian-for-categorical-variables-in-gradient-boo
$ \frac{\sum_{i=1}^{n} 1_{x_{i j}=x_{i k}} g_{i}}{\sum_{i=1}^{n} 1_{x_{i j}=x_{i k}} h_{i}} $
 -->
</section>
<section id="comparaison-des-différents-approches" class="level4" data-number="1.3.2">
<h4 data-number="1.3.2" class="anchored" data-anchor-id="comparaison-des-différents-approches"><span class="header-section-number">1.3.2</span> Comparaison des différents approches</h4>
<p>Déterminer quelle approche des variables catégorielles est adaptée dans une situation donnée n’est pas toujours aisé. Les cas d’usage des différentes approches peuvent être résumés comme ceci:</p>
<ul>
<li>le <em>one-hot-encoding</em> est adapté uniquement aux variables catégorielles comprenant peu de modalités;</li>
<li>l’<em>ordinal encoding</em> est adapté aux variables catégorielles qui sont naturellement ordonnées, et ce quel que soit le nombre de modalités (car la variable catégorielle est implicitement convertie en variable numérique);</li>
<li>le <em>target encoding</em> est adapté aux variables catégorielles comprenant un grand nombre de modalités et non naturellement ordonnées;</li>
<li>le support natif des variables catégorielles est adapté à tous les types de variables catégorielles, à l’exception de celles qui comprennent un nombre très élevé des modalités (au-delà de quelques centaines).</li>
</ul>
<p>Comparé aux autres approches, le support natif des variables catégorielles comporte plusieurs avantages: il permet de réduire le nombre de <em>splits</em>, d’obtenir des arbres plus simples et d’augmenter l’efficacité computationnelle de l’entraînement des arbres. Ces avantages apparaissent clairement avec un exemple<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>. Imaginons qu’on s’intéresse à une variable catégorielle prenant les modalités ABCDEF, et que sur une feuille donnée de l’arbre, le meilleur partitionnement sur cette variable soit ACF - BDE. Une approche de <em>one-hot-encoding</em> aura besoin de trois <em>splits</em> pour approximer ce partitionnement: un premier pour séparer A et BCDEF, un deuxième pour séparer C et BDEF et un troisième pour séparer F et BCDE (l’ordre des <em>splits</em> pouvant différer). Une approche d’<em>ordinal encoding</em> aura besoin de quatre <em>splits</em>: un <em>split</em> pour isoler A, un <em>split</em> pour isoler F, et deux splits pour isoler C (car C est au milieu de l’ordre des modalités). Enfin, une approche de <em>target encoding</em> aura besoin d’un nombre variable de <em>splits</em>, qui dépend de l’ordre des modalités dans l’<em>encoding</em>: si le <em>target encoding</em> a trié les modalités dans l’ordre ACFBDE, alors un unique <em>split</em> suffira; si l’ordre est très différent, alors il faudra davantage de <em>splits</em>. Inversement, le support natif des variables catégorielles identifiera immédiatement le partitionnement optimal, et ne fera qu’un seul <em>split</em>, ce qui simplifie la structure de l’arbre et accélère l’entraînement.</p>
<!-- Ainsi, comparées au support natif des variables catégorielles, les approches traditionnelles (_one-hot-encoding_, _ordinal encoding_ et _target encoding_) ont trois limites:

- Elles aboutissent à des arbres profonds, avec de multiples _splits_ déséquilibrés (une modalité séparée de toutes les autres);
- Les partitionnements obtenus ne sont pas forcément les plus pertinents;
- La construction des arbres est plus lente et plus coûteuse sur le plan computationnel, en raison du nombre élevé de _splits_. -->
</section>
<section id="approches-intégrées-aux-implémentations-des-méthodes-ensemblistes" class="level4" data-number="1.3.3">
<h4 data-number="1.3.3" class="anchored" data-anchor-id="approches-intégrées-aux-implémentations-des-méthodes-ensemblistes"><span class="header-section-number">1.3.3</span> Approches intégrées aux implémentations des méthodes ensemblistes</h4>
<p>Certaines implémentations des méthodes ensemblistes prennent en charge directement certaines des quatre approches présentées ci-dessus, auquel cas il est possible d’entraîner le modèle sur des données contenant des variables catégorielles sans <em>preprocessing</em> particulier; dans les autres cas, il faut préparer les données en amont de l’entraînement et de la prédiction, par exemple en utilisant un <code>ColumnTransformer</code> de <code>scikit-learn</code> (<a href="https://scikit-learn.org/dev/modules/generated/sklearn.preprocessing.OneHotEncoder.html"><code>OneHotEncoder()</code></a>, <a href="https://scikit-learn.org/dev/modules/generated/sklearn.preprocessing.TargetEncoder.html"><code>TargetEncoder()</code></a>, <a href="https://scikit-learn.org/dev/modules/generated/sklearn.preprocessing.OrdinalEncoder.html"><code>OrdinalEncoder()</code></a>). Le tableau et les notes ci-dessous résument quelles approches sont proposées par chaque implémentations des méthodes ensemblistes.</p>
<div id="tbl-preprocessing" class="quarto-float quarto-figure quarto-figure-center anchored" data-tbl-colwidths="[30,10,10,10,10]">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-preprocessing-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;1: <em>Preprocessing</em> des variables catégorielles dans les implémentations des méthodes ensemblistes
</figcaption>
<div aria-describedby="tbl-preprocessing-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 30%">
<col style="width: 10%">
<col style="width: 10%">
<col style="width: 10%">
<col style="width: 10%">
<col style="width: 10%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Approche</th>
<th style="text-align: center;"><code>ranger</code></th>
<th style="text-align: center;"><code>scikit-learn</code></th>
<th style="text-align: center;"><code>XGBoost</code></th>
<th style="text-align: center;"><code>LightGBM</code></th>
<th style="text-align: center;"><code>CatBoost</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><em>One-hot-encoding</em></td>
<td style="text-align: center;"><i class="fa fa-circle-xmark" style="color: #FF0000; font-size: 24px;"></i></td>
<td style="text-align: center;"><i class="fa fa-circle-xmark" style="color: #FF0000; font-size: 24px;"></i></td>
<td style="text-align: center;"><i class="fa fa-circle-check" style="color: #2C9B2D; font-size: 24px;"></i></td>
<td style="text-align: center;"><i class="fa fa-circle-check" style="color: #2C9B2D; font-size: 24px;"></i></td>
<td style="text-align: center;"><i class="fa fa-circle-check" style="color: #2C9B2D; font-size: 24px;"></i></td>
</tr>
<tr class="even">
<td style="text-align: left;"><em>Ordinal encoding</em></td>
<td style="text-align: center;"><i class="fa fa-circle-check" style="color: #2C9B2D; font-size: 24px;"></i></td>
<td style="text-align: center;"><i class="fa fa-circle-xmark" style="color: #FF0000; font-size: 24px;"></i></td>
<td style="text-align: center;"><i class="fa fa-circle-xmark" style="color: #FF0000; font-size: 24px;"></i></td>
<td style="text-align: center;"><i class="fa fa-circle-xmark" style="color: #FF0000; font-size: 24px;"></i></td>
<td style="text-align: center;"><i class="fa fa-circle-xmark" style="color: #FF0000; font-size: 24px;"></i></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><em>Target encoding</em></td>
<td style="text-align: center;"><i class="fa fa-circle-check" style="color: #2C9B2D; font-size: 24px;"></i></td>
<td style="text-align: center;"><i class="fa fa-circle-xmark" style="color: #FF0000; font-size: 24px;"></i></td>
<td style="text-align: center;"><i class="fa fa-circle-xmark" style="color: #FF0000; font-size: 24px;"></i></td>
<td style="text-align: center;"><i class="fa fa-circle-xmark" style="color: #FF0000; font-size: 24px;"></i></td>
<td style="text-align: center;"><i class="fa fa-circle-check" style="color: #2C9B2D; font-size: 24px;"></i></td>
</tr>
<tr class="even">
<td style="text-align: left;">Support natif des variables catégorielles</td>
<td style="text-align: center;"><i class="fa fa-circle-xmark" style="color: #FF0000; font-size: 24px;"></i></td>
<td style="text-align: center;"><i class="fa fa-circle-check" style="color: #2C9B2D; font-size: 24px;"></i></td>
<td style="text-align: center;"><i class="fa fa-circle-check" style="color: #2C9B2D; font-size: 24px;"></i></td>
<td style="text-align: center;"><i class="fa fa-circle-check" style="color: #2C9B2D; font-size: 24px;"></i></td>
<td style="text-align: center;"><i class="fa fa-circle-xmark" style="color: #FF0000; font-size: 24px;"></i></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<ul>
<li><p><code>ranger</code>: le traitement des variables catégorielles (<code>factors</code>) est contrôlé par l’argument <code>respect.unordered.factors</code>, qui peut prendre trois valeurs: <code>ignore</code> (<em>ordinal encoding</em>), <code>order</code> (<em>target encoding</em>) et <code>partition</code> (essayer toutes les combinaisons possibles). L’usage de cet argument est détaillé dans la documentation de la fonction <code>ranger()</code>. L’usage de la modalité <code>partition</code> n’est pas recommandé. En revanche, <code>ranger</code> ne prend pas en charge le <em>one-hot-encoding</em>.</p></li>
<li><p><code>LightGBM</code>: cette implémentation utilise par défaut le <em>one-hot-encoding</em> pour les variables catégorielles comprenant 4 modalités ou moins, et le support natif des variables catégorielles pour les autres. Ce seuil peut être modifié via le paramètre <code>max_cat_to_onehot</code>. En revanche, <code>LightGBM</code> ne prend pas en charge ni l’<em>ordinal encoding</em> ni le <em>target encoding</em>.</p></li>
<li><p><code>XGBoost</code>: le traitement des variables catégorielles est contrôlé par l’argument <code>enable_categorical</code>. Si <code>enable_categorical = True</code> (en Python), alors <code>XGBoost</code> applique le support natif des variables catégorielles. Par ailleurs, le paramètre <code>max_cat_to_onehot</code> permet d’utiliser le <em>one-hot-encoding</em> pour les variables catégorielles comprenant moins de <code>max_cat_to_onehot</code> modalités, et le support natif pour les autres (voir la <a href="https://xgboost.readthedocs.io/en/stable/tutorials/categorical.html">documentation</a>). En revanche, <code>XGBoost</code> ne prend pas en charge ni l’<em>ordinal encoding</em> ni le <em>target encoding</em>.</p></li>
<li><p><code>CatBoost</code>: cette implémentation est celle qui propose le plus d’options relatives aux variables catégorielles. Par défaut, elle utilise le <em>one-hot-encoding</em> pour les variables catégorielles comprenant peu de modalités, et une variante de <em>target encoding</em> aux autres. Le seuil par défaut varie selon le type de tâche et peut être modifié via le paramètre <code>one_hot_max_size</code>. La documentation de <code>CatBoost</code> propose un <a href="https://github.com/catboost/catboost/blob/master/catboost/tutorials/categorical_features/categorical_features_parameters.ipynb"><em>notebook</em></a> qui détaille les différents hyperparamètres.</p></li>
<li><p><code>scikit-learn</code>: l’implémentation du <em>gradient boosting</em> (<a href="https://scikit-learn.org/dev/modules/generated/sklearn.ensemble.HistGradientBoostingClassifier.html"><code>HistGradientBoostingClassifier</code></a>, <a href="https://scikit-learn.org/dev/modules/generated/sklearn.ensemble.HistGradientBoostingRegressor.html"><code>HistGradientBoostingRegressor</code></a>) propose le support natif des variables catégorielles. Cette implémentation ne propose pas de <em>one-hot-encoding</em> pour les variables catégorielles comprenant peu de modalités, et ne prend pas en charge ni l’<em>ordinal encoding</em> ni le <em>target encoding</em>.</p></li>
</ul>



</section>
</section>
</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-fisher1958grouping" class="csl-entry" role="listitem">
Fisher, Walter D. 1958. <span>“On Grouping for Maximum Homogeneity.”</span> <em>Journal of the American Statistical Association</em> 53 (284): 789–98.
</div>
<div id="ref-prokhorenkova2018catboost" class="csl-entry" role="listitem">
Prokhorenkova, Liudmila, Gleb Gusev, Aleksandr Vorobev, Anna Veronika Dorogush, and Andrey Gulin. 2018. <span>“CatBoost: Unbiased Boosting with Categorical Features.”</span> <em>Advances in Neural Information Processing Systems</em> 31.
</div>
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Il est bien sûr possible de n’encoder que les modalités les plus fréquentes, et de regrouper toutes les autres dans une seule variable binaire.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Le <em>target encoding</em> utilisé par CatBoost est présenté en détail dans <span class="citation" data-cites="prokhorenkova2018catboost">Prokhorenkova et al. (<a href="#ref-prokhorenkova2018catboost" role="doc-biblioref">2018</a>)</span> et sur ce <a href="https://blog.dataiku.com/how-do-gradient-boosting-algorithms-handle-categorical-variables">billet de blog</a>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Voir cet <a href="https://scikit-learn.org/dev/auto_examples/preprocessing/plot_target_encoder.html#sphx-glr-auto-examples-preprocessing-plot-target-encoder-py">exemple</a> dans la documentation de scikit-learn.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Il s’agit de l’<a href="../../chapters/chapter2/4-boosting.html#eq-w-j-optimal">équation donnant le poids optimal</a> d’une feuille terminale, avec <span class="math inline">\(\lambda = 0\)</span>.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>Cet exemple s’appuie sur la <a href="https://scikit-learn.org/dev/auto_examples/ensemble/plot_gradient_boosting_categorical.html">documentation de <code>scikit-learn</code></a>.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/github\.com\/inseefrlab\/DT_methodes_ensemblistes");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../chapters/chapter2/4-boosting.html" class="pagination-link" aria-label="Le *boosting*">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Le <em>boosting</em></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../chapters/chapter3/0-intro.html" class="pagination-link" aria-label="Comment bien utiliser les algorithmes?">
        <span class="nav-page-text">Comment bien utiliser les algorithmes?</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© CC-1.0</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/inseefrlab/DT_methodes_ensemblistes/edit/main/chapters/chapter2/ajouts_boosting.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/inseefrlab/DT_methodes_ensemblistes/blob/main/chapters/chapter2/ajouts_boosting.qmd" class="toc-action"><i class="bi empty"></i>View source</a></li><li><a href="https://github.com/inseefrlab/DT_methodes_ensemblistes/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
<p>This page is built with <a href="https://quarto.org/">Quarto</a>.</p>
</div>
  </div>
</footer>




</body></html>