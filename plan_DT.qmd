---
title: "Hello Typst!"
author: |
  [Olivier Meslin](https://github.com/oliviermeslin)
  [Mélina Hillion](https://github.com/melinahillion)
format:
  typst:
    toc: true
    section-numbering: 1.1.1
---

Restriction du champ: méthodes ensemblistes à base d'arbres.

Lecture de base: chapitres 9-12: https://bradleyboehmke.github.io/HOML/

# Survol des méthodes ensemblistes

__Principe__: cette partie propose une présentation intuitive des méthodes ensemblistes, à destination notamment des _managers_ sans bagage en _machine learning_. Elle ne contient aucune formalisation mathématique.

## Principe des méthodes ensemblistes


### Pourquoi utiliser des méthodes ensemblistes?

Avantages: 

- Méthodes adaptées à un grand nombre de cas d'usage de la statistique publique:

    - Elles sont notamment applicables à tous les problèmes pour lesquels on utilise une régression linéaire ou une régression logistisque);
    - Elles s'appliquent à des données tabulaires (enregistrements en lignes, variables en colonnes), situation très fréquente dans la statistique publique.
    
    
- Performances quasi systématiquement supérieures aux méthodes économétriques traditionnelles;
- Scalabilité: ces méthodes peuvent être appliquées à des données volumineuses;
- Coût d'entrée modéré (comparé à des approches plus avancées comme le _deep learning_)

Inconvénients:

- Bagage informatique minimal (une bonne maîtrise de Python ou R est un prérequis).
- Temps d'entraînement potentiellement long, notamment pour l'optimisation des hyperparamètres.
- Ces méthodes peuvent nécessiter une puissance de calcul importante et/ou une mémoire vive de grande taille.
- Interprétabilité moindre que les méthodes économétriques traditionnelles (et encore, ça se discute)
- Risque de surapprentissage.


### L'union fait la force

Plutôt que de chercher à construire d'emblée un unique modèle très complexe, les approches ensemblistes vise à obtenir un modèle très performant en combinant un grand nombre de modèles simples.

Il existe trois grandes approches ensemblistes: 

- le _bagging_;
- le _stacking_;
- le _boosting_.

Le présent document se concentre sur deux approches: le _bagging_ et le _boosting_.


### Critères de performance et sélection d'un modèle 

La performance d'un modèle augmente généralement avec sa complexité, jusqu'à atteindre un maximum, puis diminue. L'objectif est d'obtenir un modèle qui minimise à la fois le sous-apprentissage (biais) et le sur-apprentissage (variance). C'est ce qu'on appelle le compromis biais/variance. Cette section présente très brièvement les critères utilisés pour évaluer et comparer les performances des modèles.

## Comment fonctionnent les méthodes ensemblistes?

Quatre temps:

- les arbres de décision et de régression (CART);
- les forêts aléatoires;
- le boosting.

### Le point de départ: les arbres de décision et de régression

Présenter _decision tree_ et _regression tree_. Reprendre des éléments du chapitre 9 de https://bradleyboehmke.github.io/HOML/

Principes d'un arbre: 

- fonction constante par morceaux;
- partition de l'espace;
- interactions entre variables.

Illustration, et représentation graphique (sous forme d'arbre et de graphique).

## Le _bagging_

Reprendre des éléments du chapitre 10 de https://bradleyboehmke.github.io/HOML/

Mettre une description de l'algorithme en pseudo-code?

## Le _bagging_ et les _random forests_

### Le _bagging_

Présenter le _bagging_ en reprenant des éléments du chapitre 10 de https://bradleyboehmke.github.io/HOML.

- Présentation avec la figure en SVG;
- Illustration avec un cas d'usage de classification en deux dimensions.

### Les _random forests_

Expliquer que les _random forests_ sont une amélioration du _bagging_, en reprenant des éléments du chapitre 11 de https://bradleyboehmke.github.io/HOML/

<!-- https://neptune.ai/blog/ensemble-learning-guide -->
<!-- https://www.analyticsvidhya.com/blog/2021/06/understanding-random-forest/ -->

- Présentation avec la figure en SVG;
- Difficile d'illustrer avec un exemple (car on ne peut pas vraiment représenter le _feature sampling_);
- Bien insister sur les avantages des RF: 1/ faible nombre d'hyperparamètres; 2/ faible sensibilité aux hyperparamètres; 3/ limite intrinsèque à l'overfitting.

## Le _boosting_

Reprendre des éléments du chapitre 12 de https://bradleyboehmke.github.io/HOML/ et des éléments de la formation boosting.

Le *boosting* combine l'[**approche ensembliste**]{.orange} avec une [**modélisation additive par étapes**]{.orange} (*forward stagewise additive modeling*).

- Présentation;
- Avantage du boosting: performances particulièrement élevées.
- Inconvénients: 1/ nombre élevé d'hyperparamètres; 2/ sensibilité des performances aux hyperparamètres; 3/ risque élevé d'overfitting.

- Préciser qu'il est possible d'utiliser du subsampling par lignes et colonnes pour un algoithme de boosting. Ce point est abordé plus en détail dans la partie sur les hyperparamètres.

# Présentation détaillée du _gradient boosting_

Attention présentation détaillée et matheuse. Cette partie porte précisément sur l'optimisation par le gradient.

Bien préciser:

- il existe des implémentations du _boosting_ qui ne sont pas du _gradient boosting_ (exemple: l'_adaptative boosting_ de l'algorithme AdaBoost).
- Il existe de multiples implémentations du _gradient boosting_ (GBM, lightGBM, XGBoost, Catboost...), globalement similaires mais qui diffèrent sur des points de détail. La présentation qui suit doit donc être complétée par la lecture de la documentation des différents algorithmes.  
- cette approche permet de construire des forêts aléatoires et des modèles de _boosting_. 

L'exposé qui suit reprend les notations de l'article qui a introduit XGBoost (2016). Il est important de numéroter les équations pour faire le lien entre la partie qui liste les hyperparamètres et les équations dans lesquels ils interviennent.

## Rappels sur l'apprentissage supervisé

Reprendre les éléments figurant dans la formation boosting.

## La mécanique des approches ensemblistes

### La mécanique de la _random forest_

Mettre une description de l'algorithme en pseudo-code

Reprendre les éléments figurant dans la formation boosting.

### La mécanique du boosting

Mettre une description de l'algorithme en pseudo-code

Reprendre les éléments figurant dans la formation boosting.

## La construction d'un arbre par la descente de gradient

Donner les formules d'XGBoost. Donner un algorithme en pseudo code décrivant la façon dont XGBoost énumère les splits possibles.

Expliquer:

- l'approche _greedy_, et le _pruning_;
- l'approche par histogramme ou par énumération exacte;
- le rôle des hyperparamètres qui interviennent dans la construction des arbres.

Faire une figure détaillée d'un arbre avec des annotations (A, B, C) pour permettre des renvois depuis la liste des hyperparamètres?

## Le choix d'une fonction de perte

Exemple: Huber?

## L'utilisation des pondérations

Bien expliquer où elles interviennent.

# Comment (bien) utiliser les approches ensemblistes

## Différence entre RF et _boosting_

Comment choisir entre forêt aléatoire et boosting:

- Temps dont on dispose: RF si peu de temps;
- Puissance de calcul dont on dispose: RF si peu de puissance;
- Compréhension des algorithmes: RF si on est débutant;
- Nombre de _features_; RF si nombreuses;
- Nature du problème: y a-t-il des spécificités locales (au sens mathématique) qu'un arbre assez profond aura du mal à prendre en compte? Si oui, le _boosting_ peut aider
- Présence d'_outliers_: si oui, RF, ou alors _boosting_ avec _subsampling_.


## La préparation des données

### La _target_

- Penser aux transformations préalables (log, ratio...).
- Quid des variables catégorielles ordonnées?

### Les _features_

- Que faire des variables continues? 
    - les transformations monotones sont inutiles;
    - les transformations non monotones peuvent être utiles;
    - attention aux paramètres de la _quantization_ par histogramme;
- La gestion des variables catégorielles:
    - one hot encoding?
    - support expérimental des variables catégorielles?

## Rôle et interprétation des principaux hyperparamètres

gamma, beta, alpha, lambda, eta, M, T, nb de quantiles;
method = "hist"

Faire systématiquement le renvoi vers la partie matheuse, pour que les lecteurs sachent où intervient chaque paramètre.

## Diagnostics post-entraînement

- Mesure d'importance: intérêt et limites.
- Y a-t-il d'autres diagnostics standards?

# Interprétabilité

Quels frameworks veut-on présenter?


# Cas d'usage

- Données (pouvant être rendues) publiques
- Notebooks déployables sur le datalab
- Code en Python

## Régression

### Cas général

### Régression en présence d'outliers

=> Changement de fonction de perte

## Classification

### Cas général

### Classification déséquilibrée

=> Pondération de la classe minoritaire

<!-- IMPORTANT -->
<!-- Formations sur le ML -->
<!-- https://github.com/davidrpugh/machine-learning-for-tabular-data -->
<!-- IMPORTANT -->

<!-- Petites questions: -->
<!-- - Quelle implémentation des RF veut-on présenter? Je suis favorable à avoir un seul framework RF/Boosting, mais c'est peut-être pas standard. Quelques références: -->

<!--     - https://konfuzio.com/en/random-forest/ -->
<!--     - https://xgboost.readthedocs.io/en/stable/tutorials/rf.html -->



<!-- Petites notes complémentaires -->
<!-- - Interprétabilité: https://selfexplainml.github.io/PiML-Toolbox/_build/html/index.html -->
<!-- - Comparaison arbres et autres (Papier R Avouac): https://proceedings.neurips.cc/paper_files/paper/2022/file/0378c7692da36807bdec87ab043cdadc-Paper-Datasets_and_Benchmarks.pdf -->

<!-- https://fraud-detection-handbook.github.io/fraud-detection-handbook/Chapter_6_ImbalancedLearning/CostSensitive.html -->
